## 事件循环

### 同步事件

### 微任务和宏任务

- 微任务中包含
  Promise.then
  MutaionObserver
  await 阻塞后的内容
  Object.observe（已废弃；Proxy 对象替代）
  process.nextTick（Node.js）

- 宏任务
  定时器
  各种事件，click,render

执行一个宏任务，如果遇到微任务就将它放到微任务的事件队列中
当前宏任务执行完成后，会查看微任务的事件队列，然后将里面的所有微任务依次执行完

```javascript
async function async1() {
  console.log("async1 start");
  await async2();
  console.log("async1 end");
}
async function async2() {
  console.log("async2");
}
console.log("script start");
setTimeout(function () {
  console.log("settimeout");
});
async1();
new Promise(function (resolve) {
  console.log("promise1");
  resolve();
}).then(function () {
  console.log("promise2");
});
console.log("script end");
```

分析过程：

1. 执行整段代码，遇到 console.log('script start') 直接打印结果，输出 script start
2. 遇到定时器了，它是宏任务，先放着不执行
3. 遇到 async1()，执行 async1 函数，先打印 async1 start，下面遇到 await 怎么办？先执行 async2，打印 async2，然后阻塞下面代码（即加入微任务列表），跳出去执行同步代码
4. 跳到 new Promise 这里，直接执行，打印 promise1，下面遇到 .then()，它是微任务，放到微任务列表等待执行
5. 最后一行直接打印 script end，现在同步代码执行完了，开始执行微任务，即 await 下面的代码，打印 async1 end
6. 继续执行下一个微任务，即执行 then 的回调，打印 promise2
7. 上一个宏任务所有事都做完了，开始下一个宏任务，就是定时器，打印 settimeout

所以最后的结果是：script start、async1 start、async2、promise1、script end、async1 end、promise2、settimeout


## event loop细分
在浏览器的 Event Loop 里，一般的执行顺序是这样：

1. 执行同步代码（主线程）。
2. 执行所有 微任务（Promise.then、MutationObserver 等）。
3. 渲染前阶段：执行 requestAnimationFrame 回调。
4. 浏览器执行页面渲染（绘制）。
5. 如果有需要，进入下一次循环，处理宏任务（如 setTimeout/setInterval）。

所以实际上requestAnimationFrame既不是宏任务也不是微任务，而是一个独特的阶段

```js
console.log("start")

requestAnimationFrame(() => console.log("rAF"))

setTimeout(() => console.log("timeout"), 0)

Promise.resolve().then(() => console.log("microtask"))

console.log("end")
```

```js
start
end
microtask     // 微任务先执行
rAF           // 下一次渲染前
timeout       // 宏任务（下一轮事件循环）

```
