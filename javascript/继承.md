## 继承

### 原型链继承，构造函数继承，组合继承，寄生组合继承

在开始了解继承之前，我们首先了解 new 的机制，这段代码修改 prototype 属性导致 constructor 回溯到了 object

```javascript
function A() {}
A.prototype = {
  sayHi() {
    console.log("Hi");
  },
};

const a = new A();
console.log(a.constructor === A); // ❌ false
console.log(a.constructor); // Object，因为 constructor 默认指向 Object
```

这个现象的本质根源，在于 `new` 关键字在实例化时的行为 —— 它会将实例对象的 `__proto__` 指向构造函数的 `prototype`。而不是去管你 `prototype` 上有没有 `constructor` 属性。因此，如果你手动重写了 `prototype`，**默认的 `constructor` 属性就会丢失**，从而导致 `a.constructor !== A`。

## 🔍 从 `new A()` 的角度看发生了什么

### ✅ 执行 `new A()` 实际发生了以下步骤：

```js
function A() {}
A.prototype = { sayHi() {} }; // 🚨 你手动改写了 prototype 对象

const a = new A();
```

相当于 JavaScript 内部执行了下面这些步骤（简化）：

### 1️⃣ 创建一个新对象 `a`：

```js
const a = {}; // 创建一个空对象
```

### 2️⃣ 将新对象的 `__proto__` 指向 `A.prototype`

```js
Object.setPrototypeOf(a, A.prototype); // 即：a.__proto__ = A.prototype
```

现在：

```js
a.__proto__ === A.prototype; // ✅ true
```

---

### 🔥 关键点：你自己手动赋值了 `A.prototype`

```js
A.prototype = {
  sayHi() {
    console.log("Hi");
  },
};
```

这行代码 **用一个“纯对象”替换了原有的 `A.prototype` 对象**，新的这个对象没有 `constructor` 属性。JavaScript 不会帮你自动补上。

> 原本 `A.prototype` 是默认生成的，长这样：

```js
A.prototype = {
  constructor: A, // 默认存在
  __proto__: Object.prototype,
};
```

而你手动替换之后：

```js
A.prototype = {
  sayHi() { ... }
}
// ❌ 没有 constructor 属性了
```

所以：

```js
((a.constructor === a.__proto__.constructor) === A.prototype.constructor) ===
  undefined;
```

于是：

```js
a.constructor === Object; // ❌ fallback 到 Object 构造函数
```

## ✅ 如何修复？

你只需手动把 `constructor` 加回去：

```js
A.prototype = {
  constructor: A, // 👈 手动加回来
  sayHi() {
    console.log("Hi");
  },
};
```

### 原型链继承

```javascript
function parent() {
  this.name = "parent";
  this.play = [1, 2, 3];
}

function child() {
  this.type = "child2";
}

//原型链继承实现方式，即指定继承类的原型对象为父类对象
child1.prototype = new parent();
child1.prototype.constructor = child1();
```

方法优点：
这种方法的缺点是： 当出现两个实例对共享父类的引用对象，因为他们的原型对象实际上是 new 出来的一个实例对象

```javascript
var s1 = new Child2();
var s2 = new Child2();
s1.play.push(4);
console.log(s1.play, s2.play); // [1,2,3,4]
```

### 构造函数继承

```javascript
function Parent() {
  this.name = "parent1";
}

Parent.prototype.getName = function () {
  return this.name;
};

function Child() {
  //构造函数继承实现方式，在继承类的构造过程中使用父类的call方法绑定
  Parent1.call(this);
  this.type = "child";
// 第一次调用 Parent3()
// 原型链继承
Child3.prototype = new Parent3();}

let child = new Child();
console.log(child); // 没问题
console.log(child.getName()); // 会报错
```

优点： 解决了原型链继承造成的共享引用属性问题
缺点： 只能继承父类的实例属性和方法，无法继承原型属性和方法

### 组合继承

```javascript
function Parent3() {
  this.name = "parent3";
  this.play = [1, 2, 3];
}

Parent3.prototype.getName = function () {
  return this.name;
};
function Child3() {
  // 第二次调用 Parent3()
  // 构造函数继承
  Parent3.call(this);
  this.type = "child3";
}

// 第一次调用 Parent3()
// 原型链继承
Child3.prototype = new Parent3();
// 手动挂上构造器，指向自己的构造函数
Child3.prototype.constructor = Child3;
var s3 = new Child3();
var s4 = new Child3();
s3.play.push(4);
console.log(s3.play, s4.play); // 不互相影响
console.log(s3.getName()); // 正常输出'parent3'
console.log(s4.getName()); // 正常输出'parent3'
```

优点： 解决了原型链继承的重复问题和构造函数继承的无法继承原型属性问题
缺点： 调用两次父类的构造函数, 由于子类构造函数的原型对象为父类的实例对象，导致重复了父类的属性声明，不会导致问题，但是导致了冗余，实际上可以通过原型链向上回溯找到

### 寄生组合继承

> Object.create(proto) 当调用这个函数时，返回一个空对象，且这个空对象的\_\_proto\_\_ === proto

```javascript
function Parent3() {
  this.name = "parent3";
  this.play = [1, 2, 3];
}

Parent3.prototype.getName = function () {
  return this.name;
};
function Child3() {
  // 第二次调用 Parent3()
  // 构造函数继承
  Parent3.call(this);
  this.type = "child3";
}
//创建一个没有实例方法的父类对象作为子类的原型对象
Child3.prototype = Object.create(Parent3.prototype);
// 手动挂上构造器，指向自己的构造函数
Child3.prototype.constructor = Child3;
var s3 = new Child3();
var s4 = new Child3();
s3.play.push(4);
console.log(s3.play, s4.play); // 不互相影响
console.log(s3.getName()); // 正常输出'parent3'
console.log(s4.getName()); // 正常输出'parent3'
```

缺点： 在 Child3 指定原型对象前所有定义在原型上的属性将丢失
