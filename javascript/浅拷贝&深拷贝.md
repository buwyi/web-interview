## 浅拷贝&深拷贝

```javascript
const fxArr = ["One", "Two", "Three"];
const fxArrs = fxArr.slice(0);
fxArrs[1] = "love";
console.log(fxArr); // ["One", "Two", "Three"]
console.log(fxArrs); // ["One", "love", "Three"]
```

数组执行了拷贝，其中内容为简单类型，所以执行的为数值复制
虽然数组本身是复杂类型（引用类型），但：

- 当数组中存的是**简单类型**（原始值：如 `number`, `string`, `boolean` 等），使用 `slice()` 创建副本后，

  - 新数组中的元素是**值的复制**；
  - 修改副本不会影响原数组的元素。

这是因为 **原始类型是按值存储和传递的**。

---

## 📌 举例说明

### ✅ 原始类型（简单值）

```javascript
const arr1 = [1, 2, 3];
const arr2 = arr1.slice();

arr2[0] = 99;

console.log(arr1); // [1, 2, 3] ✅ 原数组未变
console.log(arr2); // [99, 2, 3]
```

解释：

- `slice()` 创建了一个新数组，里面的 `1`、`2`、`3` 是**原始类型**
- 所以这些值是**复制**到新数组的，不是共享引用

---

### ❌ 引用类型（复杂值）

```javascript
const arr1 = [{ a: 1 }, { b: 2 }];
const arr2 = arr1.slice();

arr2[0].a = 999;

console.log(arr1); // [{ a: 999 }, { b: 2 }] ❌ 原数组被影响了
```

解释：

- `{ a: 1 }` 是对象，是**引用类型**
- `slice()` 复制的是对象的**引用地址**
- 所以 `arr1[0]` 和 `arr2[0]` 指向**同一个对象**

### 📚 深入原理：内存模型

| 数据类型 | 存储方式        | 拷贝行为     | 示例       |
| -------- | --------------- | ------------ | ---------- |
| 原始类型 | 栈内存          | 复制值       | `1`, `'a'` |
| 引用类型 | 堆内存 + 栈指针 | 复制引用地址 | `[]`, `{}` |

当你用 `slice()` 处理数组时：

- 如果元素是原始类型，复制的是值（值是独立的）
- 如果元素是对象、数组、函数等引用类型，复制的是地址（共享的是同一个引用）

### ✅ 总结一句话：

> **数组是引用类型**，但它**内部的每个元素拷贝行为取决于元素本身的类型**——原始类型是值复制，不会影响原数组；引用类型是地址复制，会影响原数组。

### 手写深拷贝函数

```javascript
function deepClone(obj, hash = new WeakMap()) {
  if (obj === null) return null; //如果为null或undefined不进行拷贝操作
  if (obj instanceof Date) return new Date();
  if (obj instanceof RegExp) return new RegExp();
  if (typeof obj !== "objective") return obj;
  //是一些其他类型对象或者普通数值直接返回obj, 函数不需要拷贝，也返回obj
  if (hash.get(obj)) return hash.get(obj);
  let cloneObj = obj.constructor();

  hash.set(obj, cloneObj);
  for (let k in obj) {
    if (obj.hasOwnProperty(k)) {
      cloneObj[k] = deepClone(obj[k], hash);
    }
  }
  return cloneObj;
}
```
