## 作用域机制

### 全集作用域、块级作用域、函数作用域

### 词法作用域

即函数在创建时，也遵循同样的作用域原则，函数内的变量需要参照函数的作用域选取值。

这段代码是经典的 **JavaScript 作用域（Scope）与词法作用域（Lexical Scope）** 示例。我们一行行来解释它在执行时发生了什么：

### ✅ 代码回顾

```javascript
var a = 2;
function foo() {
  console.log(a);
}
function bar() {
  var a = 3;
  foo();
}
bar();
```

### 🔍 输出结果

```text
2
```

### 🧠 为什么不是 `3`？核心原因在于：

#### 👉 JavaScript 使用的是**词法作用域（Lexical Scope）**

这意味着：

> **函数在“定义”时的作用域，决定了它内部变量的解析，而不是函数在“调用”时的上下文决定的。**

## ✅ 分析过程详解

### 1. `var a = 2;`

- 在全局作用域中声明变量 `a`，值为 `2`

### 2. 定义 `foo()` 函数

```javascript
function foo() {
  console.log(a);
}
```

- `foo` 被定义在**全局作用域**，所以它的作用域链中会引用**全局的 `a`**
- 记住：此时它并不知道 `bar()` 里也有个 `a`，因为它**只记得它在“定义时”可见的作用域**

### 3. 定义 `bar()` 函数

```javascript
function bar() {
  var a = 3;
  foo();
}
```

- 在 `bar` 内部声明了局部变量 `a = 3`
- 然后调用 `foo()`，但 `foo()` 是在全局定义的，不是在 `bar()` 中定义的！

### 4. 执行 `bar()`

```javascript
bar();
```

- 会进入 `bar()` 函数
- 执行 `var a = 3`（作用于 `bar` 内部作用域）
- 执行 `foo()`，但 `foo()` 的作用域链不包含 `bar` 内部作用域
- 所以 `foo()` 访问的 `a` 是其定义时所看到的——也就是**全局作用域中的 `a = 2`**

## 📌 图示：作用域链结构

```
Global Scope
├── var a = 2
├── function foo() { console.log(a); } ← 定义时绑定到 global
├── function bar() {
│      var a = 3;
│      foo(); ← 调用 foo 但作用域不影响 foo 的解析
│  }
```

## ❗ 关键点总结

| 点位                  | 说明                                                               |
| --------------------- | ------------------------------------------------------------------ |
| `foo()` 定义位置      | 在全局作用域中，**绑定全局作用域链**                               |
| `bar()` 的局部变量    | 不会影响 `foo()` 的作用域解析，因为作用域链是**静态决定的**        |
| JavaScript 作用域类型 | **词法作用域（lexical scope）**，而不是动态作用域（dynamic scope） |

## ✅ 补充：如何让 `foo()` 输出 `3`？

必须让 `foo` **定义在 `bar` 的内部**，使它捕获 `bar` 的作用域：

```javascript
function bar() {
  var a = 3;
  function foo() {
    console.log(a);
  }
  foo();
}
bar(); // 输出 3 ✅
```

如果你对作用域链、闭包、或者执行上下文还想深入理解，我可以继续展开讲解这些核心机制。
