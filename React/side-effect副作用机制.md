Side Effect副作用机制
即，组件过程中预期范围外的结果
我们需要从纯函数的角度来理解副作用到底是什么意思。

## 纯函数
纯函数通常具备以下特征：
- 只负责自己的任务。 不会更改在函数调用前就已经存在的对象或者变量, 纯函数内修改的变量都是只在自身作用域内起效的组件
- 输入相同则输出相同，因为纯函数通常被视为一个公式，给定相同的输入，总是会得到相同的输出

```jsx
function double(number) {
  return 2 * number;
}
// 纯函数

function doubleNode(number){
  return <div>{2 * number}</div>
}
//纯函数组件

let guest = 0;

function Cup() {
  // Bad：正在更改预先存在的变量！
  guest = guest + 1;
  return <h2>Tea cup for guest #{guest}</h2>;
}

export default function TeaSet() {
  return (
    <>
      <Cup />
      <Cup />
      <Cup />
    </>
  );
}
```

上面的Cup组件就不是一个纯函数组件，因为他在调用的过程中，修改了全局存在的变量guest.

## 严格模式检测纯函数租金啊

因为在开发环境中，严格模式包裹下的组件，react框架会进行两次调用，这样就可以根据两次调用结果是否相同，判断组件是否是一个纯函数组件, 严格模式在生产环境下不生效

## 副作用机制
某些事物 在特定情况下不得不发生改变。这是编程的要义！这些变动包括更新屏幕、启动动画、更改数据等，它们被称为 副作用。它们是 “额外” 发生的事情，与渲染过程无关。
在 React 中，副作用通常属于 事件处理程序。事件处理程序是 React 在你执行某些操作（如单击按钮）时运行的函数。即使事件处理程序是在你的组件 内部 定义的，它们也不会在渲染期间运行！ 因此事件处理程序无需是纯函数。
如果你用尽一切办法，仍无法为副作用找到合适的事件处理程序，你还可以调用组件中的 useEffect 方法将其附加到返回的 JSX 中。这会告诉 React 在渲染结束后执行它。然而，这种方法应该是你最后的手段。

## 纯函数的好处
首先，作为一个只相当于公式，总是返回相同结果的纯函数，可以在diffing算法中保持相当好的性能，跳过渲染
其次，纯函数的纯粹性意味着他可以安全的停止计算。想象这样一个场景，一个会根据输入框而变化的页面，在用户在输入框内交互时，会重新渲染页面。当页面尚未渲染完成时，出现用户的再次输入，这个时候如果我们是一个纯函数组件，那就能直接放弃掉这次渲染，直接进行计算用户的最新输入引起的渲染，因为纯函数是一个不会影响外部函数的函数，所以绝对是安全的。但是如果这个组件不是一个纯函数组件，他的内部会进行一些对于外部变量的操作，那么就不能中断这次渲染，而是必须要等它执行完毕才能进行下一次渲染。这就是纯函数能节省时间在过时的渲染上的例子。这个能够随时中断渲染的特性，是react 的fiber框架支持的。


