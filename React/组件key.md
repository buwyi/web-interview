## 组件key的讲究

- key在兄弟节点是唯一的，不要求全局唯一，因为react在进行diffing算法比较时，只比较当前层级的节点
- key不能改变，否则会导致渲染错误


## 组件的 key 为什么不能设置成循环的 index 项

设想一下，假如你桌面上的文件都没有文件名，取而代之的是，你需要通过文件的位置顺序来区分它们———第一个文件，第二个文件，以此类推。也许你也不是不能接受这种方式，可是一旦你删除了其中的一个文件，这种组织方式就会变得混乱无比。原来的第二个文件可能会变成第一个文件，第三个文件会成为第二个文件……

React 里需要 key 和文件夹里的文件需要有文件名的道理是类似的。它们（key 和文件名）都让我们可以从众多的兄弟元素中唯一标识出某一项（JSX 节点或文件）。而一个精心选择的 key 值所能提供的信息远远不止于这个元素在数组中的位置。即使元素的位置在渲染的过程中发生了改变，它提供的 key 值也能让 React 在整个生命周期中一直认得它。

你可能会想直接把数组项的索引当作 key 值来用，实际上，如果你没有显式地指定 key 值，React 确实默认会这么做。但是数组项的顺序在插入、删除或者重新排序等操作中会发生改变，此时把索引顺序用作 key 值会产生一些微妙且令人困惑的 bug。
正如上面说的文件的例子，如果使用索引当作 key 用标识组件，那么当发生了插入删除更改顺序的操作后，引起 index 变化导致 key 的变化，会让 react 错误的复用组件，造成错误的使用体验
举个例子来说：
本来一个列表的 key 时 index 进行索引，一共有三个 item，key 分别为 0，1，2
这个时候我们在开头增加一个 item， 那么 key 变成了 0，1，2，3
这个时候会发生的现象就是，我们插入的 item 复用了之前的 0
在新视图中本来该是 0 的 item 复用了 1，以此类推

与之类似，请不要在运行过程中动态地产生 key，像是 key={Math.random()} 这种方式。这会导致每次重新渲染后的 key 值都不一样，从而使得所有的组件和 DOM 元素每次都要重新创建。这不仅会造成运行变慢的问题，更有可能导致用户输入的丢失。比如说，在一个使用了随机 key 的子组件中保存了用户输入的内容，再一次渲染的过程中，这个 key 发生了变化，react 将其认为一个全新的组件，重新渲染，让用户本来保存的输入值消失。所以，使用能从给定数据中稳定取得的值才是明智的选择。
