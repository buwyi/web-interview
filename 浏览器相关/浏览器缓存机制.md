# 浏览器缓存机制

## 按照存储位置划分

- service worker

是一种作为线程独立运行于浏览器背后的存在，一般可以用来实现缓存功能，具体的功能详解看了一参照文档[](https://developer.mozilla.org/zh-CN/docs/Web/API/Service_Worker_API/Using_Service_Workers#service_worker_%E7%9A%84%E8%83%8C%E6%99%AF)

service worker 的工作流程如下

1. 首先使用 register() 注册一个 service worker
2. install() 完成视为完成安装
3. 等待旧版本的 worker 控制的页面关闭，并且安全停用旧版本
4. 新安装的 worker 收到 activate 事件，当然也能跳过第四步，使用 skipWaiting()函数跳过等待
5. 激活后的 worker 会控制页面，控制那些在 register 后打开的页面

注意点： worker 必须运行在 HTTPS 环境下，因为 worker 会拦截请求，所以需要 HTTPS 的写一来保障安全性

- memory cache

存储与内存中的缓存，高效缓存，存储内容少，随着进程释放而结束，当 tab 标签关闭，内存中的缓存即被释放。
一块重要的缓存资源是**preloader**相关指令，页面优化的常见指令，一边解析文件一边发送请求
memory cache 在缓存资源时并不关心返回值的 header 中的 cache-control 是什么值，同时资源匹配也并非仅对 URL 做匹配，可能还会对 cache-control， CORS 等其他特征做校验

- disk cache

磁盘中的缓存

- push cache

推送缓存，存在于HTTP/2中，只在会话(session)中存在，会话结束即被释放，并且缓存时间短暂，并非严格执行请求头的缓存策略
存在以下的特点
1. 所有资源都能被推送，并且缓存，不同浏览器支持有差异
2. 可以推送头部变量为no-cache和no-store的资源
3. 一旦连接关闭，push cache被释放
4. 多个页面可以使用同一个HTTP/2的连接，也就可以使用同一个Push Cache。这主要还是依赖浏览器的实现而定，出于对性能的考虑，有的浏览器会对相同域名但不同的tab标签使用同一个HTTP连接。
5. push cache中的缓存只能被使用一次， 类似于service worker缓存中的内容
6. 浏览器可以拒绝接受
7. 可以给其他域名推送资源


## 缓存使用规则
- 强缓存

强缓存是一种，依据判定是否超出时间或者某个时间段，来判断是否使用缓存的策略，而不关心服务器的资源文件是否发生过更新
会使用到的字段有：
Expired -> HTTP/1.0
Cache-control -> HTTP/1.1 (可以使用多种指令组合)
- 协商缓存

协商缓存是一种，会进行客户端与服务端之间的通信，比较资源文件是否更新来决定是否使用缓存的策略
使用到的字段有
Last-Modified 服务器返回  ->  客户端在使用协商缓存考虑时，使用 If-Modified-Since 向服务器发送请求， 服务器比较不同的时间，来判断文件是否改动，秒级别， 如果没有改动返回304和空相应题，有改动返回200和响应体
ETag 和 If-None-Match 和上一种类似，不过Etag更加严格，会检测字节级的更改，上一种检测时间上的更改， 如果时间过快则无法察觉

优先使用强缓存，失效进入协商缓存， 最后是请求

## 缓存机制
如果未设置， 启发式算法为， 相应体的Date减去Last-Modified 乘以10%作为缓存时间
- 频繁变动场景下， Cache-Control: no-cache 即，每次都请求服务器判断是否发生变化，如果变化返回响应数据，未变化使用缓存
- 不常变化， Cache-Control: max-age: 31536000 一年时间

## 用户对于缓存的使用

- 打开网页，从地址栏输入地址， 在这次浏览器session中新开启页面进程， 从disk cache中查找相关资源
- 普通刷新，F5， tab没有关闭，memory cache可用，disk cache 其次
- 强制刷新，ctrl+F5, 发送请求头部全带有 Cache-Control: no-cache, 